<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ğŸŒŸ ×œ××“×• × ×™×§×•×“ ×¢× ×—! ğŸŒŸ</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

@keyframes bounce {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.2); }
}
@keyframes sparkle {
  0% { transform: scale(0) rotate(0deg); opacity: 1; }
  50% { transform: scale(1.2) rotate(180deg); opacity: 1; }
  100% { transform: scale(0) rotate(360deg); opacity: 0; }
}
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  20% { transform: translateX(-8px); }
  40% { transform: translateX(8px); }
  60% { transform: translateX(-6px); }
  80% { transform: translateX(6px); }
}
@keyframes float {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
}
@keyframes starRise {
  0% { transform: translateY(40px) scale(0); opacity: 0; }
  50% { opacity: 1; }
  100% { transform: translateY(-60px) scale(1.5); opacity: 0; }
}
@keyframes popIn {
  0% { transform: scale(0); }
  70% { transform: scale(1.15); }
  100% { transform: scale(1); }
}
@keyframes rainbow {
  0% { color: #ff6b9d; }
  25% { color: #c44dff; }
  50% { color: #ffd93d; }
  75% { color: #6bcb77; }
  100% { color: #ff6b9d; }
}
@keyframes cardFlip {
  0% { transform: rotateY(0deg); }
  100% { transform: rotateY(180deg); }
}
@keyframes cardFlipBack {
  0% { transform: rotateY(180deg); }
  100% { transform: rotateY(0deg); }
}
@keyframes matchPulse {
  0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(107, 203, 119, 0.7); }
  50% { transform: scale(1.05); box-shadow: 0 0 20px 10px rgba(107, 203, 119, 0.3); }
  100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(107, 203, 119, 0); }
}

body {
  font-family: 'Comic Sans MS', 'Segoe UI', Arial, sans-serif;
  background: linear-gradient(135deg, #ffecd2, #fcb69f, #ff9a9e, #fad0c4);
  background-size: 400% 400%;
  animation: gradientShift 8s ease infinite;
  min-height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
  overflow-x: hidden;
}

@keyframes gradientShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

.game-container {
  max-width: 800px;
  width: 95%;
  padding: 30px;
  text-align: center;
  position: relative;
}

/* Decorative floating elements */
.decor {
  position: fixed;
  font-size: 30px;
  opacity: 0.3;
  animation: float 3s ease-in-out infinite;
  pointer-events: none;
  z-index: 0;
}

/* Screen visibility */
.screen { display: none; }
.screen.active { display: block; }

/* Welcome screen */
.welcome-title {
  font-size: 56px;
  color: #c44dff;
  text-shadow: 3px 3px 0 #ffd93d, 5px 5px 0 rgba(0,0,0,0.1);
  margin-bottom: 10px;
  animation: bounce 2s ease-in-out infinite;
}
.welcome-subtitle {
  font-size: 32px;
  color: #ff6b9d;
  margin-bottom: 30px;
}
.welcome-words {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 12px;
  margin-bottom: 30px;
}
.welcome-word {
  background: white;
  border-radius: 20px;
  padding: 10px 20px;
  font-size: 28px;
  box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  color: #6a1b9a;
}

/* Buttons */
.btn {
  display: inline-block;
  padding: 20px 50px;
  font-size: 32px;
  font-family: inherit;
  border: none;
  border-radius: 25px;
  cursor: pointer;
  transition: all 0.2s;
  font-weight: bold;
}
.btn:hover { transform: scale(1.08); }
.btn:active { transform: scale(0.95); }

.btn-start {
  background: linear-gradient(135deg, #6bcb77, #4caf50);
  color: white;
  box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
  font-size: 38px;
  padding: 22px 60px;
}

.btn-option {
  display: block;
  width: 100%;
  max-width: 500px;
  margin: 10px auto;
  padding: 18px 30px;
  font-size: 36px;
  background: white;
  color: #4a148c;
  border: 4px solid #e1bee7;
  border-radius: 20px;
  box-shadow: 0 4px 15px rgba(0,0,0,0.08);
  cursor: pointer;
  transition: all 0.2s;
  font-family: inherit;
}
.btn-option:hover {
  border-color: #ce93d8;
  background: #fce4ec;
  transform: scale(1.03);
}
.btn-option.correct {
  background: #c8e6c9;
  border-color: #66bb6a;
  animation: bounce 0.5s;
}
.btn-option.wrong {
  background: #ffcdd2;
  border-color: #ef9a9a;
  animation: shake 0.5s;
}
.btn-option:disabled { cursor: default; }
.btn-option:disabled:hover { transform: none; }

/* Progress bar */
.progress-container {
  margin-bottom: 20px;
}
.progress-bar {
  width: 100%;
  height: 24px;
  background: rgba(255,255,255,0.5);
  border-radius: 12px;
  overflow: hidden;
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
}
.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #ff6b9d, #c44dff, #ffd93d);
  background-size: 200% 100%;
  border-radius: 12px;
  transition: width 0.5s ease;
  animation: gradientShift 3s ease infinite;
}
.progress-text {
  font-size: 18px;
  color: #6a1b9a;
  margin-top: 6px;
}

/* Stars display */
.stars-display {
  font-size: 28px;
  margin-bottom: 15px;
  color: #ff8f00;
}

/* Question area */
.question-label {
  font-size: 24px;
  color: #6a1b9a;
  margin-bottom: 10px;
}
.question-word {
  font-size: 64px;
  color: #4a148c;
  margin-bottom: 20px;
  text-shadow: 2px 2px 0 rgba(0,0,0,0.05);
}
.options-area {
  margin-top: 10px;
}

/* Feedback overlay */
.feedback {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.3);
  justify-content: center;
  align-items: center;
  z-index: 100;
}
.feedback.show { display: flex; }
.feedback-box {
  background: white;
  border-radius: 30px;
  padding: 40px 50px;
  text-align: center;
  animation: popIn 0.4s ease;
  box-shadow: 0 10px 40px rgba(0,0,0,0.2);
  max-width: 90%;
}
.feedback-icon { font-size: 72px; margin-bottom: 10px; }
.feedback-text { font-size: 32px; color: #4a148c; }

/* End screen */
.end-stars {
  font-size: 48px;
  margin: 20px 0;
}
.end-message {
  font-size: 28px;
  color: #6a1b9a;
  margin-bottom: 10px;
}
.end-score {
  font-size: 36px;
  color: #ff8f00;
  margin-bottom: 25px;
}
.btn-restart {
  background: linear-gradient(135deg, #ff6b9d, #c44dff);
  color: white;
  box-shadow: 0 6px 20px rgba(196, 77, 255, 0.4);
}

/* Memory game */
.memory-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 14px;
  max-width: 600px;
  margin: 0 auto;
}
.memory-card {
  perspective: 600px;
  height: 110px;
  cursor: pointer;
}
.memory-card-inner {
  position: relative;
  width: 100%;
  height: 100%;
  transition: transform 0.5s;
  transform-style: preserve-3d;
}
.memory-card.flipped .memory-card-inner {
  transform: rotateY(180deg);
}
.memory-card-front, .memory-card-back {
  position: absolute;
  width: 100%;
  height: 100%;
  backface-visibility: hidden;
  border-radius: 16px;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 28px;
  font-family: inherit;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}
.memory-card-front {
  background: linear-gradient(135deg, #ce93d8, #ba68c8);
  color: white;
  font-size: 36px;
}
.memory-card-back {
  background: white;
  color: #4a148c;
  transform: rotateY(180deg);
  border: 3px solid #e1bee7;
  padding: 5px;
  word-break: break-word;
}
.memory-card.matched .memory-card-back {
  background: #c8e6c9;
  border-color: #66bb6a;
  animation: matchPulse 0.6s ease;
}
.memory-card.matched { pointer-events: none; }

/* Voice / speaker button */
.speaker-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 120px;
  height: 120px;
  border-radius: 50%;
  border: 5px solid #e1bee7;
  background: linear-gradient(135deg, #f3e5f5, #fff);
  font-size: 64px;
  cursor: pointer;
  transition: all 0.2s;
  box-shadow: 0 6px 20px rgba(0,0,0,0.12);
  margin-bottom: 20px;
  animation: pulseGlow 2s ease-in-out infinite;
}
.speaker-btn:hover { transform: scale(1.1); border-color: #ce93d8; }
.speaker-btn:active { transform: scale(0.95); }
@keyframes pulseGlow {
  0%, 100% { box-shadow: 0 6px 20px rgba(0,0,0,0.12); }
  50% { box-shadow: 0 6px 30px rgba(196, 77, 255, 0.35); }
}
.speaker-hint {
  font-size: 22px;
  color: #8e24aa;
  margin-bottom: 18px;
}

/* Floating star particles */
.star-particle {
  position: fixed;
  font-size: 32px;
  pointer-events: none;
  z-index: 200;
  animation: starRise 1s ease-out forwards;
}

/* Word selector */
.word-selector {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 12px;
  margin-bottom: 25px;
}
.word-chip {
  position: relative;
  cursor: pointer;
  user-select: none;
}
.word-chip input {
  position: absolute;
  opacity: 0;
  width: 0;
  height: 0;
}
.word-chip label {
  display: flex;
  align-items: center;
  gap: 8px;
  background: white;
  border: 4px solid #e1bee7;
  border-radius: 20px;
  padding: 10px 20px;
  font-size: 28px;
  color: #6a1b9a;
  cursor: pointer;
  transition: all 0.2s;
  box-shadow: 0 4px 15px rgba(0,0,0,0.08);
}
.word-chip input:checked + label {
  background: #e8f5e9;
  border-color: #66bb6a;
  box-shadow: 0 4px 15px rgba(102, 187, 106, 0.3);
}
.word-chip label:hover {
  transform: scale(1.05);
  border-color: #ce93d8;
}
.word-chip .chip-check {
  font-size: 20px;
}
.word-chip input:checked + label .chip-check::after { content: 'âœ…'; }
.word-chip input:not(:checked) + label .chip-check::after { content: 'â¬œ'; }

.select-actions {
  margin-bottom: 15px;
  display: flex;
  justify-content: center;
  gap: 12px;
}
.btn-small {
  padding: 8px 20px;
  font-size: 18px;
  font-family: inherit;
  border: 3px solid #ce93d8;
  border-radius: 14px;
  background: white;
  color: #6a1b9a;
  cursor: pointer;
  transition: all 0.2s;
}
.btn-small:hover { background: #f3e5f5; transform: scale(1.05); }

.min-warning {
  color: #e53935;
  font-size: 18px;
  margin-bottom: 10px;
  display: none;
}

/* Add word form */
.add-word-section {
  margin: 20px 0;
  padding: 20px;
  background: rgba(255,255,255,0.7);
  border-radius: 20px;
  border: 3px dashed #ce93d8;
}
.add-word-title {
  font-size: 22px;
  color: #6a1b9a;
  margin-bottom: 12px;
}
.add-word-row {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 10px;
  margin-bottom: 10px;
}
.add-word-row input {
  padding: 10px 14px;
  font-size: 22px;
  font-family: inherit;
  border: 3px solid #e1bee7;
  border-radius: 14px;
  text-align: center;
  width: 160px;
  outline: none;
  transition: border-color 0.2s;
  direction: rtl;
}
.add-word-row input:focus { border-color: #ab47bc; }
.add-word-row input::placeholder { color: #ccc; font-size: 18px; }
.btn-add {
  padding: 10px 24px;
  font-size: 22px;
  font-family: inherit;
  border: none;
  border-radius: 14px;
  background: linear-gradient(135deg, #6bcb77, #4caf50);
  color: white;
  cursor: pointer;
  transition: all 0.2s;
  font-weight: bold;
}
.btn-add:hover { transform: scale(1.05); }
.add-word-error {
  color: #e53935;
  font-size: 16px;
  margin-top: 6px;
  min-height: 22px;
}

/* Nikud Editor */
.nikud-editor-base-input {
  padding: 10px 14px;
  font-size: 24px;
  font-family: inherit;
  border: 3px solid #e1bee7;
  border-radius: 14px;
  text-align: center;
  width: 220px;
  outline: none;
  transition: border-color 0.2s;
  direction: rtl;
}
.nikud-editor-base-input:focus { border-color: #ab47bc; }
.nikud-editor-base-input::placeholder { color: #ccc; font-size: 18px; }

.nikud-letter-tiles {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 8px;
  margin: 12px 0;
  direction: rtl;
}
.nikud-letter-tile {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 60px;
  height: 70px;
  background: white;
  border: 3px solid #e1bee7;
  border-radius: 14px;
  font-size: 32px;
  color: #4a148c;
  cursor: pointer;
  transition: all 0.2s;
  box-shadow: 0 3px 10px rgba(0,0,0,0.08);
  user-select: none;
  font-family: inherit;
}
.nikud-letter-tile:hover { border-color: #ce93d8; transform: scale(1.05); }
.nikud-letter-tile.selected {
  border-color: #9c27b0;
  background: #f3e5f5;
  box-shadow: 0 0 12px rgba(156, 39, 176, 0.3);
  transform: scale(1.08);
}

.nikud-palette {
  display: none;
  flex-wrap: wrap;
  justify-content: center;
  gap: 8px;
  margin: 12px 0;
  padding: 12px;
  background: rgba(243, 229, 245, 0.5);
  border-radius: 16px;
}
.nikud-palette.visible { display: flex; }

.nikud-mark-btn {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 70px;
  height: 70px;
  background: white;
  border: 3px solid #e1bee7;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.2s;
  padding: 4px;
  font-family: inherit;
}
.nikud-mark-btn:hover { border-color: #ce93d8; transform: scale(1.08); }
.nikud-mark-btn.active {
  border-color: #7b1fa2;
  background: #e8f5e9;
  box-shadow: 0 0 8px rgba(76, 175, 80, 0.3);
}
.nikud-mark-btn .mark-preview {
  font-size: 28px;
  color: #4a148c;
  line-height: 1;
}
.nikud-mark-btn .mark-name {
  font-size: 11px;
  color: #6a1b9a;
  line-height: 1.1;
  margin-top: 2px;
}

.nikud-preview {
  font-size: 40px;
  color: #4a148c;
  margin: 10px 0;
  min-height: 50px;
  direction: rtl;
}
.nikud-preview-label {
  font-size: 16px;
  color: #8e24aa;
  margin-bottom: 4px;
}

/* Delete button on custom word chips */
.word-chip .chip-delete {
  font-size: 16px;
  cursor: pointer;
  margin-right: 4px;
  opacity: 0.6;
  transition: opacity 0.2s;
}
.word-chip .chip-delete:hover { opacity: 1; }

/* Game settings */
.game-settings {
  margin: 20px 0;
  padding: 20px;
  background: rgba(255,255,255,0.7);
  border-radius: 20px;
  border: 3px dashed #ce93d8;
}
.game-settings-title {
  font-size: 22px;
  color: #6a1b9a;
  margin-bottom: 12px;
}
.setting-row {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 10px;
  margin-bottom: 14px;
}
.setting-row:last-child { margin-bottom: 0; }
.setting-label {
  font-size: 20px;
  color: #6a1b9a;
  margin-bottom: 6px;
  text-align: center;
  width: 100%;
}
.setting-btn {
  padding: 10px 22px;
  font-size: 20px;
  font-family: inherit;
  border: 3px solid #ce93d8;
  border-radius: 16px;
  background: white;
  color: #6a1b9a;
  cursor: pointer;
  transition: all 0.2s;
}
.setting-btn:hover { background: #f3e5f5; transform: scale(1.05); }
.setting-btn.active {
  background: linear-gradient(135deg, #ab47bc, #8e24aa);
  color: white;
  border-color: #8e24aa;
  box-shadow: 0 3px 12px rgba(142, 36, 170, 0.3);
}

/* Assembly mode */
.assemble-dropzone {
  display: flex;
  flex-direction: row;
  justify-content: center;
  flex-wrap: wrap;
  gap: 8px;
  margin: 20px auto;
  min-height: 80px;
  padding: 10px;
}
.assemble-slot {
  width: 60px;
  height: 70px;
  border: 3px dashed #ce93d8;
  border-radius: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 32px;
  color: #4a148c;
  background: rgba(255,255,255,0.5);
  cursor: pointer;
  transition: all 0.2s;
}
.assemble-slot.drag-over {
  border-color: #ab47bc;
  background: rgba(206,147,216,0.2);
  transform: scale(1.08);
}
.assemble-slot.filled {
  border-style: solid;
  border-color: #ab47bc;
  background: white;
  box-shadow: 0 3px 10px rgba(0,0,0,0.08);
  animation: popIn 0.3s ease;
}
.assemble-slot.correct-slot {
  border-color: #66bb6a;
  background: #c8e6c9;
  box-shadow: 0 0 15px rgba(102, 187, 106, 0.4);
  animation: bounce 0.5s;
}
.assemble-slot.needs-nikud {
  border-bottom: 4px solid #f48fb1;
}
.assemble-slot.has-nikud {
  border-bottom: 4px solid #66bb6a;
}
.assemble-pieces {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: center;
  gap: 10px;
  margin: 20px auto;
  padding: 12px;
  background: rgba(243,229,245,0.3);
  border-radius: 16px;
}
.assemble-piece {
  width: 60px;
  height: 70px;
  background: white;
  border: 3px solid #e1bee7;
  border-radius: 14px;
  font-size: 32px;
  color: #4a148c;
  cursor: grab;
  transition: opacity 0.2s, transform 0.2s, box-shadow 0.2s;
  box-shadow: 0 3px 10px rgba(0,0,0,0.08);
  font-family: inherit;
  animation: popIn 0.3s ease;
  touch-action: none;
  user-select: none;
}
.assemble-piece:hover { border-color: #ce93d8; transform: scale(1.08); }
.assemble-piece:active { cursor: grabbing; }
.assemble-piece.dragging {
  opacity: 0.5;
  transform: scale(1.1);
  box-shadow: 0 8px 25px rgba(0,0,0,0.2);
}
.assemble-piece.used {
  opacity: 0.15;
  pointer-events: none;
  transform: scale(0.85);
}
.assemble-piece.nikud-piece {
  width: 40px;
  height: 50px;
  font-size: 28px;
  border-color: #f48fb1;
  background: #fff0f5;
}
.assemble-piece.distractor {
  border-style: dashed;
}
.assemble-section-label {
  width: 100%;
  text-align: center;
  font-size: 18px;
  color: #8e24aa;
  margin: 8px 0 4px;
}

/* Recording modal */
.record-modal {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.4);
  justify-content: center;
  align-items: center;
  z-index: 150;
}
.record-modal.show { display: flex; }
.record-modal-box {
  background: white;
  border-radius: 30px;
  padding: 30px 40px;
  text-align: center;
  animation: popIn 0.4s ease;
  box-shadow: 0 10px 40px rgba(0,0,0,0.2);
  max-width: 90%;
  min-width: 300px;
}
.record-modal-title {
  font-size: 28px;
  color: #4a148c;
  margin-bottom: 8px;
}
.record-modal-word {
  font-size: 36px;
  color: #6a1b9a;
  margin-bottom: 16px;
}
.record-btn {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  border: 4px solid #e1bee7;
  background: white;
  font-size: 40px;
  cursor: pointer;
  transition: all 0.2s;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.record-btn:hover { transform: scale(1.1); }
.record-btn.recording {
  border-color: #e53935;
  background: #ffebee;
  animation: pulseRecord 1s ease-in-out infinite;
}
@keyframes pulseRecord {
  0%, 100% { box-shadow: 0 0 0 0 rgba(229,57,53,0.4); }
  50% { box-shadow: 0 0 20px 10px rgba(229,57,53,0.2); }
}
.record-status {
  font-size: 20px;
  color: #6a1b9a;
  margin: 12px 0;
  min-height: 28px;
}
.record-actions {
  display: flex;
  justify-content: center;
  gap: 10px;
  margin-top: 10px;
}
.record-actions button {
  padding: 8px 20px;
  font-size: 18px;
  font-family: inherit;
  border: 3px solid #ce93d8;
  border-radius: 14px;
  background: white;
  color: #6a1b9a;
  cursor: pointer;
  transition: all 0.2s;
}
.record-actions button:hover { background: #f3e5f5; transform: scale(1.05); }
.record-actions .btn-save {
  background: linear-gradient(135deg, #6bcb77, #4caf50);
  color: white;
  border-color: #4caf50;
}
.record-actions .btn-save:hover { background: linear-gradient(135deg, #7ddb89, #5cbf60); }

/* Mic button on word chips */
.word-chip .chip-mic {
  font-size: 16px;
  cursor: pointer;
  margin-right: 4px;
  opacity: 0.7;
  transition: opacity 0.2s;
}
.word-chip .chip-mic:hover { opacity: 1; }

/* Responsive */
@media (max-width: 600px) {
  .welcome-title { font-size: 40px; }
  .question-word { font-size: 48px; }
  .btn-option { font-size: 28px; padding: 14px 20px; }
  .btn { font-size: 26px; padding: 16px 36px; }
  .memory-grid { grid-template-columns: repeat(2, 1fr); }
  .memory-card { height: 100px; }
  .memory-card-back { font-size: 22px; }
  .assemble-slot, .assemble-piece { width: 50px; height: 60px; font-size: 26px; }
  .assemble-piece.nikud-piece { width: 46px; height: 56px; font-size: 24px; }
  .setting-btn { font-size: 17px; padding: 8px 16px; }
}
</style>
</head>
<body>

<!-- Decorations -->
<div class="decor" style="top:5%;left:5%;animation-delay:0s;">â­</div>
<div class="decor" style="top:15%;right:8%;animation-delay:0.5s;">ğŸ’œ</div>
<div class="decor" style="bottom:20%;left:10%;animation-delay:1s;">ğŸŒŸ</div>
<div class="decor" style="top:40%;right:3%;animation-delay:1.5s;">ğŸ’–</div>
<div class="decor" style="bottom:10%;right:12%;animation-delay:2s;">â­</div>
<div class="decor" style="top:60%;left:3%;animation-delay:0.8s;">âœ¨</div>

<div class="game-container">

  <!-- Welcome Screen -->
  <div id="welcome-screen" class="screen active">
    <div class="welcome-title">ğŸŒŸ ×œ××“×• × ×™×§×•×“! ğŸŒŸ</div>
    <div class="welcome-subtitle">×‘×—×¨×• ××ª ×”××™×œ×™× ×œ××©×—×§</div>
    <div class="select-actions">
      <button class="btn-small" onclick="selectAll()">×‘×—×¨ ×”×›×œ âœ…</button>
      <button class="btn-small" onclick="selectNone()">× ×§×” ×”×›×œ â¬œ</button>
    </div>
    <div class="word-selector" id="word-selector"></div>
    <div class="min-warning" id="min-warning">âš ï¸ ×‘×—×¨×• ×œ×¤×—×•×ª 3 ××™×œ×™×</div>

    <!-- Add word form with visual nikud editor -->
    <div class="add-word-section">
      <div class="add-word-title">â• ×”×•×¡×™×¤×• ××™×œ×” ×—×“×©×”</div>

      <!-- Step 1: Type base letters -->
      <div class="add-word-row">
        <input type="text" id="nikud-base-input" class="nikud-editor-base-input" placeholder="×”×§×œ×™×“×• ××•×ª×™×•×ª ×‘×œ×™ × ×™×§×•×“" dir="rtl">
      </div>

      <!-- Step 2: Letter tiles -->
      <div class="nikud-letter-tiles" id="nikud-letter-tiles"></div>

      <!-- Step 3: Nikud palette (shown when a letter is selected) -->
      <div class="nikud-palette" id="nikud-palette"></div>

      <!-- Live preview -->
      <div class="nikud-preview-label" id="nikud-preview-label" style="display:none;">:×ª×¦×•×’×” ××§×“×™××”</div>
      <div class="nikud-preview" id="nikud-preview"></div>

      <!-- Meaning & pronunciation -->
      <div class="add-word-row">
        <input type="text" id="add-meaning" placeholder="××©××¢×•×ª" dir="rtl">
        <input type="text" id="add-speak" placeholder="××™×š ×œ×§×¨×•×" dir="rtl">
      </div>
      <button class="btn-add" onclick="addCustomWord()">×”×•×¡×£ âœ…</button>
      <div class="add-word-error" id="add-word-error"></div>
    </div>

    <!-- Game settings -->
    <div class="game-settings">
      <div class="setting-label">ğŸ® ×¡×•×’ ××©×—×§</div>
      <div class="setting-row">
        <button class="setting-btn active" data-setting="gameMode" data-value="voice" onclick="setSetting(this)">ğŸ”Š ×©××¢ ×•×‘×—×¨</button>
        <button class="setting-btn" data-setting="gameMode" data-value="assemble" onclick="setSetting(this)">ğŸ”¤ ×”×¨×›×‘ ××™×œ×”</button>
        <button class="setting-btn" data-setting="gameMode" data-value="mixed" onclick="setSetting(this)">ğŸ² ××¢×•×¨×‘</button>
      </div>
      <div class="setting-label">ğŸ“Š ×¨××ª ×§×•×©×™</div>
      <div class="setting-row">
        <button class="setting-btn active" data-setting="difficulty" data-value="easy" onclick="setSetting(this)">ğŸ˜Š ×§×œ</button>
        <button class="setting-btn" data-setting="difficulty" data-value="advanced" onclick="setSetting(this)">ğŸ’ª ××ª×§×“×</button>
      </div>
    </div>

    <br>
    <button class="btn btn-start" onclick="startGame()">!×‘×•××• × ×œ××“ âœ¨</button>
  </div>

  <!-- Game Screen -->
  <div id="game-screen" class="screen">
    <div class="stars-display" id="stars-display">â­ 0</div>
    <div class="progress-container">
      <div class="progress-bar"><div class="progress-fill" id="progress-fill" style="width:0%"></div></div>
      <div class="progress-text" id="progress-text">×©××œ×” 1 ××ª×•×š 10</div>
    </div>
    <div class="question-label" id="question-label"></div>
    <div class="question-word" id="question-word"></div>
    <div class="options-area" id="options-area"></div>
  </div>

  <!-- End Screen -->
  <div id="end-screen" class="screen">
    <div class="welcome-title" style="animation:rainbow 2s infinite, bounce 2s ease-in-out infinite;">!×›×œ ×”×›×‘×•×“ ğŸ‰</div>
    <div class="end-stars" id="end-stars"></div>
    <div class="end-score" id="end-score"></div>
    <div class="end-message" id="end-message"></div>
    <br>
    <button class="btn btn-restart" onclick="startGame()">ğŸ”„ !×©×—×§×• ×©×•×‘</button>
    <br><br>
    <button class="btn-small" onclick="showScreen('welcome-screen')" style="font-size:22px;padding:12px 28px;">ğŸ“ ×‘×—×™×¨×ª ××™×œ×™×</button>
  </div>

</div>

<!-- Recording modal -->
<div class="record-modal" id="record-modal">
  <div class="record-modal-box">
    <div class="record-modal-title">ğŸ™ï¸ ×”×§×œ×˜×ª ××™×œ×”</div>
    <div class="record-modal-word" id="record-modal-word"></div>
    <button class="record-btn" id="record-btn" onclick="toggleRecording()">ğŸ™ï¸</button>
    <div class="record-status" id="record-status">×œ×—×¦×• ×œ×”×§×œ×˜×”</div>
    <div class="record-actions" id="record-actions" style="display:none;">
      <button onclick="playbackRecording()">ğŸ”Š ×”×©××¢</button>
      <button onclick="reRecord()">ğŸ”„ ×”×§×œ×˜ ×©×•×‘</button>
      <button class="btn-save" onclick="saveRecording()">ğŸ’¾ ×©××•×¨</button>
    </div>
    <div class="record-actions" style="margin-top:8px;">
      <button onclick="closeRecordModal()">âœ– ×¡×’×•×¨</button>
    </div>
  </div>
</div>

<!-- Feedback overlay -->
<div class="feedback" id="feedback">
  <div class="feedback-box">
    <div class="feedback-icon" id="feedback-icon"></div>
    <div class="feedback-text" id="feedback-text"></div>
  </div>
</div>

<script>
// ===== WORD DATA =====
const DEFAULT_WORDS = [
  { nikud: '×—Ö·×œÖ¼×•Ö¹×ª', meaning: '×—×œ×•×ª (×œ×—×)',       speak: '×—×œ×•×ª' },
  { nikud: '×—Ö¸×‘Öµ×¨',  meaning: '×—×‘×¨ (×™×“×™×“)',       speak: '×—×‘×¨' },
  { nikud: '×—Ö»×œÖ°×¦Ö¸×”', meaning: '×—×•×œ×¦×” (×‘×’×“)',      speak: '×—×•×œ×¦×”' },
  { nikud: '×—Ö´×‘Ö¼×•Ö¼×§', meaning: '×—×™×‘×•×§',           speak: '×—×™×‘×•×§' },
  { nikud: '×—Ö¶×“Ö¶×¨',  meaning: '×—×“×¨',              speak: '×—×“×¨' },
  { nikud: '×—Ö¸×›Ö¸×',  meaning: '×—×›× (×¤×™×§×—)',       speak: '×—×›×' },
  { nikud: '×—×•Ö¹×œÖ¶×”', meaning: '×—×•×œ×” (×œ× ×‘×¨×™×)',   speak: '×—×•×œ×”' },
  { nikud: '×—Ö²×–Ö¸×¨Ö¸×”', meaning: '×—×–×¨×”',             speak: '×—×–×¨×”' },
  { nikud: '×—Ö¹×¨Ö¶×£',  meaning: '×—×•×¨×£ (×¢×•× ×”)',      speak: '×—×•×¨×£' },
  { nikud: '×—×•Ö¹×Ö¸×”', meaning: '×—×•××” (×§×™×¨)',       speak: '×—×•××”' },
];

// Load custom words from localStorage
function loadCustomWords() {
  try {
    return JSON.parse(localStorage.getItem('nikud_custom_words') || '[]');
  } catch(e) { return []; }
}
function saveCustomWords(words) {
  localStorage.setItem('nikud_custom_words', JSON.stringify(words));
}

// All words = defaults + custom
let WORDS = [...DEFAULT_WORDS, ...loadCustomWords()];

// Strip nikud from a string to get base letters
function stripNikud(str) {
  return str.replace(/[\u0591-\u05C7]/g, '');
}

// Normalize a nikud string so visually-identical strings compare equal
function normalizeNikud(str) {
  return str.normalize('NFC');
}

// Fake nikud variants for distractors
function generateFakeNikud(word) {
  // Create plausible-looking wrong nikud by assigning random vowel marks
  const vowelNikud = ['\u05B0','\u05B1','\u05B2','\u05B3','\u05B4','\u05B5','\u05B6','\u05B7','\u05B8','\u05B9','\u05BB'];
  const baseLetters = stripNikud(word.nikud).split('');
  let fake = '';
  for (let i = 0; i < baseLetters.length; i++) {
    fake += baseLetters[i];
    // Each letter gets a random vowel mark (70% chance) or none (30%)
    if (Math.random() < 0.7) {
      fake += vowelNikud[Math.floor(Math.random() * vowelNikud.length)];
    }
    // Small chance of dagesh too
    if (Math.random() < 0.15) {
      fake += '\u05BC';
    }
  }
  return normalizeNikud(fake);
}

// ===== AUDIO (Web Audio API) =====
let audioCtx;
function getAudioCtx() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}
function playTone(freq, duration, type='sine') {
  try {
    const ctx = getAudioCtx();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(0.3, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start();
    osc.stop(ctx.currentTime + duration);
  } catch(e) {}
}
function playCorrectSound() {
  playTone(523, 0.15);
  setTimeout(() => playTone(659, 0.15), 100);
  setTimeout(() => playTone(784, 0.3), 200);
}
function playWrongSound() {
  playTone(300, 0.2, 'triangle');
  setTimeout(() => playTone(250, 0.3, 'triangle'), 150);
}
function playMatchSound() {
  playTone(600, 0.1);
  setTimeout(() => playTone(750, 0.1), 80);
  setTimeout(() => playTone(900, 0.2), 160);
}
function playEndSound() {
  [523,659,784,1047].forEach((f,i) => setTimeout(() => playTone(f, 0.3), i*150));
}

// ===== SPEECH SYNTHESIS (Hebrew voice) =====
let hebrewVoice = null;
function initHebrewVoice() {
  const voices = speechSynthesis.getVoices();
  // Try to find a Hebrew voice
  hebrewVoice = voices.find(v => v.lang.startsWith('he')) || null;
}
// Voices load asynchronously in some browsers
if (typeof speechSynthesis !== 'undefined') {
  speechSynthesis.onvoiceschanged = initHebrewVoice;
  initHebrewVoice();
}

function speakHebrew(text) {
  if (typeof speechSynthesis === 'undefined') return;
  speechSynthesis.cancel(); // stop any current speech
  const utter = new SpeechSynthesisUtterance(text);
  utter.lang = 'he-IL';
  utter.rate = 0.75; // slower for kids
  utter.pitch = 1.1;
  if (hebrewVoice) utter.voice = hebrewVoice;
  speechSynthesis.speak(utter);
}

// ===== WORD SELECTOR =====
function buildWordSelector() {
  const container = document.getElementById('word-selector');
  container.innerHTML = '';
  const customWords = loadCustomWords();
  WORDS.forEach((w, i) => {
    const isCustom = i >= DEFAULT_WORDS.length;
    const chip = document.createElement('div');
    chip.className = 'word-chip';
    const hasAudio = getWordAudio(w.nikud);
    chip.innerHTML = `
      <input type="checkbox" id="word-${i}" data-index="${i}" checked>
      <label for="word-${i}">
        <span class="chip-check"></span>
        <span>${w.nikud}</span>
        <span style="font-size:18px;color:#888;">(${w.meaning})</span>
        <span class="chip-mic" onclick="event.preventDefault();event.stopPropagation();openRecordModal(${i});" title="×”×§×œ×˜×”">${hasAudio ? 'ğŸ™ï¸âœ…' : 'ğŸ™ï¸'}</span>
        ${isCustom ? `<span class="chip-delete" onclick="event.preventDefault();event.stopPropagation();deleteCustomWord(${i - DEFAULT_WORDS.length});" title="××—×§">âŒ</span>` : ''}
      </label>
    `;
    container.appendChild(chip);
  });
}
function selectAll() {
  document.querySelectorAll('#word-selector input').forEach(cb => cb.checked = true);
  document.getElementById('min-warning').style.display = 'none';
}
function selectNone() {
  document.querySelectorAll('#word-selector input').forEach(cb => cb.checked = false);
}
function getSelectedWords() {
  const selected = [];
  document.querySelectorAll('#word-selector input:checked').forEach(cb => {
    selected.push(WORDS[parseInt(cb.dataset.index)]);
  });
  return selected;
}

// ===== NIKUD EDITOR =====
const NIKUD_MARKS = [
  { char: '\u05B0', name: '×©×•×•×',      sample: '×©Ö°×' },
  { char: '\u05B1', name: '×—×˜×£ ×¤×ª×—',   sample: '×—Ö²' },
  { char: '\u05B2', name: '×—×˜×£ ×¡×’×•×œ',  sample: '×—Ö±' },
  { char: '\u05B3', name: '×—×˜×£ ×§××¥',   sample: '×—Ö³' },
  { char: '\u05B4', name: '×—×™×¨×™×§',     sample: '×—Ö´' },
  { char: '\u05B5', name: '×¦×™×¨×”',      sample: '×—Öµ' },
  { char: '\u05B6', name: '×¡×’×•×œ',      sample: '×—Ö¶' },
  { char: '\u05B7', name: '×¤×ª×—',       sample: '×—Ö·' },
  { char: '\u05B8', name: '×§××¥',       sample: '×—Ö¸' },
  { char: '\u05B9', name: '×—×•×œ×',      sample: '×—Ö¹' },
  { char: '\u05BB', name: '×§×•×‘×•×¥',     sample: '×—Ö»' },
  { char: '\u05BC', name: '×“×’×©',       sample: '×—Ö¼' },
  { char: '\u05C1', name: '×©×™×Ÿ ×™××™×Ÿ',  sample: '×©×' },
  { char: '\u05C2', name: '×©×™×Ÿ ×©×××œ',  sample: '×©×‚' },
];

// Editor state: array of { letter: string, marks: Set of nikud chars }
let nikudEditorLetters = [];
let nikudEditorSelected = -1; // index of currently selected letter

function initNikudEditor() {
  const baseInput = document.getElementById('nikud-base-input');
  baseInput.addEventListener('input', onBaseInputChange);

  // Build the palette (always the same, just shown/hidden)
  buildNikudPalette();
}

function onBaseInputChange() {
  const baseInput = document.getElementById('nikud-base-input');
  const rawText = baseInput.value;
  // Extract only Hebrew base letters (no nikud, no spaces for now)
  const hebrewLetters = rawText.replace(/[^\u05D0-\u05EA]/g, '');

  // Rebuild letters array, preserving existing marks where possible
  const oldLetters = nikudEditorLetters;
  nikudEditorLetters = [];
  for (let i = 0; i < hebrewLetters.length; i++) {
    if (i < oldLetters.length && oldLetters[i].letter === hebrewLetters[i]) {
      nikudEditorLetters.push(oldLetters[i]);
    } else {
      nikudEditorLetters.push({ letter: hebrewLetters[i], marks: new Set() });
    }
  }

  // Reset selection if out of bounds
  if (nikudEditorSelected >= nikudEditorLetters.length) {
    nikudEditorSelected = -1;
  }

  renderLetterTiles();
  renderNikudPreview();
  updatePaletteState();
}

function renderLetterTiles() {
  const container = document.getElementById('nikud-letter-tiles');
  container.innerHTML = '';
  nikudEditorLetters.forEach((item, i) => {
    const tile = document.createElement('div');
    tile.className = 'nikud-letter-tile' + (i === nikudEditorSelected ? ' selected' : '');
    // Show letter with its marks
    let display = item.letter;
    item.marks.forEach(m => display += m);
    tile.textContent = display;
    tile.onclick = () => selectLetterTile(i);
    container.appendChild(tile);
  });

  // Show/hide preview label
  const previewLabel = document.getElementById('nikud-preview-label');
  previewLabel.style.display = nikudEditorLetters.length > 0 ? 'block' : 'none';
}

function selectLetterTile(index) {
  nikudEditorSelected = (nikudEditorSelected === index) ? -1 : index;
  renderLetterTiles();
  updatePaletteState();
}

function buildNikudPalette() {
  const palette = document.getElementById('nikud-palette');
  palette.innerHTML = '';
  NIKUD_MARKS.forEach((mark, i) => {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'nikud-mark-btn';
    btn.dataset.markIndex = i;
    btn.innerHTML = `<span class="mark-preview">${mark.sample}</span><span class="mark-name">${mark.name}</span>`;
    btn.onclick = () => toggleNikudMark(i);
    palette.appendChild(btn);
  });
}

function updatePaletteState() {
  const palette = document.getElementById('nikud-palette');
  if (nikudEditorSelected < 0 || nikudEditorSelected >= nikudEditorLetters.length) {
    palette.classList.remove('visible');
    return;
  }
  palette.classList.add('visible');

  const currentMarks = nikudEditorLetters[nikudEditorSelected].marks;
  palette.querySelectorAll('.nikud-mark-btn').forEach(btn => {
    const mi = parseInt(btn.dataset.markIndex);
    btn.classList.toggle('active', currentMarks.has(NIKUD_MARKS[mi].char));
  });
}

function toggleNikudMark(markIndex) {
  if (nikudEditorSelected < 0 || nikudEditorSelected >= nikudEditorLetters.length) return;
  const marks = nikudEditorLetters[nikudEditorSelected].marks;
  const ch = NIKUD_MARKS[markIndex].char;
  if (marks.has(ch)) {
    marks.delete(ch);
  } else {
    marks.add(ch);
  }
  renderLetterTiles();
  renderNikudPreview();
  updatePaletteState();
}

function renderNikudPreview() {
  const preview = document.getElementById('nikud-preview');
  let word = '';
  nikudEditorLetters.forEach(item => {
    word += item.letter;
    item.marks.forEach(m => word += m);
  });
  preview.textContent = word || '';
}

function getEditorNikudWord() {
  let word = '';
  nikudEditorLetters.forEach(item => {
    word += item.letter;
    item.marks.forEach(m => word += m);
  });
  return word;
}

function resetNikudEditor() {
  nikudEditorLetters = [];
  nikudEditorSelected = -1;
  document.getElementById('nikud-base-input').value = '';
  renderLetterTiles();
  renderNikudPreview();
  updatePaletteState();
}

// Add a custom word
function addCustomWord() {
  const meaningInput = document.getElementById('add-meaning');
  const speakInput = document.getElementById('add-speak');
  const errorEl = document.getElementById('add-word-error');

  const nikud = getEditorNikudWord().trim();
  const meaning = meaningInput.value.trim();
  const speak = speakInput.value.trim();

  if (!nikud || !meaning) {
    errorEl.textContent = 'âš ï¸ ×™×© ×œ××œ× ××™×œ×” ×¢× × ×™×§×•×“ ×•××©××¢×•×ª';
    return;
  }

  const newWord = {
    nikud: nikud,
    meaning: meaning,
    speak: speak || stripNikud(nikud)
  };

  // Check for duplicates
  if (WORDS.some(w => w.nikud === nikud)) {
    errorEl.textContent = 'âš ï¸ ××™×œ×” ×–×• ×›×‘×¨ ×§×™×™××ª';
    return;
  }

  const custom = loadCustomWords();
  custom.push(newWord);
  saveCustomWords(custom);
  WORDS = [...DEFAULT_WORDS, ...custom];

  // Clear inputs
  resetNikudEditor();
  meaningInput.value = '';
  speakInput.value = '';
  errorEl.textContent = '';

  buildWordSelector();
}

// Delete a custom word
function deleteCustomWord(customIndex) {
  const custom = loadCustomWords();
  custom.splice(customIndex, 1);
  saveCustomWords(custom);
  WORDS = [...DEFAULT_WORDS, ...custom];
  buildWordSelector();
}

// Build selector on load
buildWordSelector();

// Init nikud editor
initNikudEditor();

// ===== GAME SETTINGS =====
let gameMode = 'voice';   // 'voice', 'assemble', 'mixed'
let difficulty = 'easy';   // 'easy', 'advanced'

function setSetting(btn) {
  const setting = btn.dataset.setting;
  const value = btn.dataset.value;
  // Update global
  if (setting === 'gameMode') gameMode = value;
  if (setting === 'difficulty') difficulty = value;
  // Update button UI: deactivate siblings, activate this one
  btn.parentElement.querySelectorAll('.setting-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
}

// ===== CUSTOM AUDIO RECORDING =====
function audioStorageKey(nikudStr) {
  return 'nikud_audio_' + btoa(unescape(encodeURIComponent(nikudStr)));
}
function saveWordAudio(nikudStr, audioDataUrl) {
  localStorage.setItem(audioStorageKey(nikudStr), audioDataUrl);
}
function getWordAudio(nikudStr) {
  return localStorage.getItem(audioStorageKey(nikudStr));
}
function deleteWordAudio(nikudStr) {
  localStorage.removeItem(audioStorageKey(nikudStr));
}

// Play word audio: use custom recording if available, otherwise TTS
function playWordAudio(text, speakText) {
  const customAudio = getWordAudio(text);
  if (customAudio) {
    const audio = new Audio(customAudio);
    audio.play().catch(() => {});
    return;
  }
  speakHebrew(speakText || text);
}

// Recording state
let recordingWord = null;    // the word object being recorded
let mediaRecorder = null;
let recordedChunks = [];
let recordedDataUrl = null;

function openRecordModal(wordIndex) {
  const word = WORDS[wordIndex];
  recordingWord = word;
  recordedDataUrl = null;
  recordedChunks = [];

  document.getElementById('record-modal-word').textContent = word.nikud;
  document.getElementById('record-status').textContent = '×œ×—×¦×• ×œ×”×§×œ×˜×”';
  document.getElementById('record-actions').style.display = 'none';
  document.getElementById('record-btn').className = 'record-btn';
  document.getElementById('record-btn').textContent = 'ğŸ™ï¸';
  document.getElementById('record-modal').classList.add('show');
}

function closeRecordModal() {
  document.getElementById('record-modal').classList.remove('show');
  if (mediaRecorder && mediaRecorder.state === 'recording') {
    mediaRecorder.stop();
  }
  mediaRecorder = null;
  recordingWord = null;
}

function toggleRecording() {
  if (mediaRecorder && mediaRecorder.state === 'recording') {
    // Stop recording
    mediaRecorder.stop();
    return;
  }
  // Start recording
  recordedChunks = [];
  recordedDataUrl = null;
  document.getElementById('record-actions').style.display = 'none';

  navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
    mediaRecorder = new MediaRecorder(stream);
    mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
    mediaRecorder.onstop = () => {
      stream.getTracks().forEach(t => t.stop());
      const blob = new Blob(recordedChunks, { type: 'audio/webm' });
      const reader = new FileReader();
      reader.onloadend = () => {
        recordedDataUrl = reader.result;
        document.getElementById('record-status').textContent = '×”×”×§×œ×˜×” ××•×›× ×”!';
        document.getElementById('record-actions').style.display = 'flex';
        document.getElementById('record-btn').className = 'record-btn';
        document.getElementById('record-btn').textContent = 'ğŸ™ï¸';
      };
      reader.readAsDataURL(blob);
    };
    mediaRecorder.start();
    document.getElementById('record-status').textContent = '...××§×œ×™×˜';
    document.getElementById('record-btn').className = 'record-btn recording';
    document.getElementById('record-btn').textContent = 'â¹ï¸';
  }).catch(() => {
    document.getElementById('record-status').textContent = '×©×’×™××”: ××™×Ÿ ×’×™×©×” ×œ××™×§×¨×•×¤×•×Ÿ';
  });
}

function playbackRecording() {
  if (recordedDataUrl) {
    new Audio(recordedDataUrl).play().catch(() => {});
  }
}

function reRecord() {
  recordedDataUrl = null;
  recordedChunks = [];
  document.getElementById('record-actions').style.display = 'none';
  document.getElementById('record-status').textContent = '×œ×—×¦×• ×œ×”×§×œ×˜×”';
}

function saveRecording() {
  if (!recordedDataUrl || !recordingWord) return;
  saveWordAudio(recordingWord.nikud, recordedDataUrl);
  closeRecordModal();
  buildWordSelector(); // refresh chips to show âœ…
}

// ===== GAME STATE =====
let score = 0;
let currentQuestion = 0;
let totalQuestions = 10;
let questionQueue = [];
let memoryState = null;
let activeWords = []; // words selected for current game
let answerLocked = false; // prevent double-click on answers

// ===== UTILITIES =====
function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
function pick(arr, n) { return shuffle(arr).slice(0, n); }

function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

function spawnStarParticles(x, y) {
  const emojis = ['â­','ğŸŒŸ','âœ¨','ğŸ’›','ğŸ’–'];
  for (let i = 0; i < 6; i++) {
    const el = document.createElement('div');
    el.className = 'star-particle';
    el.textContent = emojis[Math.floor(Math.random() * emojis.length)];
    el.style.left = (x + (Math.random()-0.5)*80) + 'px';
    el.style.top = (y + Math.random()*30) + 'px';
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 1100);
  }
}

function showFeedback(isCorrect, extraText) {
  const fb = document.getElementById('feedback');
  const icon = document.getElementById('feedback-icon');
  const text = document.getElementById('feedback-text');
  if (isCorrect === true) {
    icon.textContent = ['ğŸŒŸ','â­','ğŸ’–','ğŸ‰','âœ¨'][Math.floor(Math.random()*5)];
    text.textContent = ['!××¦×•×™×Ÿ','!×›×œ ×”×›×‘×•×“','!× ×›×•×Ÿ','!×™×•×¤×™','!××¢×•×œ×”'][Math.floor(Math.random()*5)];
  } else {
    icon.textContent = 'ğŸ˜•';
    text.textContent = extraText || '!× × ×¡×” ×©×•×‘';
  }
  fb.classList.add('show');
  const delay = (isCorrect === true) ? 1000 : 1500;
  setTimeout(() => {
    fb.classList.remove('show');
    answerLocked = false;
    nextQuestion();
  }, delay);
}

function updateUI() {
  document.getElementById('stars-display').textContent = 'â­ ' + score;
  document.getElementById('progress-fill').style.width = ((currentQuestion) / totalQuestions * 100) + '%';
  document.getElementById('progress-text').textContent = '×©××œ×” ' + (currentQuestion + 1) + ' ××ª×•×š ' + totalQuestions;
}

// ===== GAME START =====
function startGame() {
  // Get selected words
  activeWords = getSelectedWords();
  if (activeWords.length < 3) {
    document.getElementById('min-warning').style.display = 'block';
    return;
  }
  document.getElementById('min-warning').style.display = 'none';

  score = 0;
  currentQuestion = 0;
  memoryState = null;
  totalQuestions = activeWords.length;

  // Build question queue based on game mode
  const shuffledWords = shuffle(activeWords);
  questionQueue = [];

  for (let i = 0; i < totalQuestions; i++) {
    const word = shuffledWords[i];
    if (gameMode === 'voice') {
      questionQueue.push({ type: 'voice', word });
    } else if (gameMode === 'assemble') {
      questionQueue.push({ type: 'assemble', word });
    } else {
      // mixed: alternate
      questionQueue.push({ type: (i % 2 === 0) ? 'voice' : 'assemble', word });
    }
  }

  showScreen('game-screen');
  updateUI();
  showQuestion();
}

function showQuestion() {
  if (currentQuestion >= totalQuestions) {
    endGame();
    return;
  }

  // Find the next question from queue
  let q = questionQueue.shift();
  if (!q) { endGame(); return; }

  updateUI();

  if (q.type === 'nikud') showNikudQuestion(q.word);
  else if (q.type === 'meaning') showMeaningQuestion(q.word);
  else if (q.type === 'voice') showVoiceQuestion(q.word);
  else if (q.type === 'assemble') showAssembleQuestion(q.word);
  else if (q.type === 'memory') showMemoryQuestion(q.words);
}

function nextQuestion() {
  currentQuestion++;
  updateUI();
  showQuestion();
}

// ===== MODE 1: PICK THE CORRECT NIKUD =====
function showNikudQuestion(word) {
  document.getElementById('question-label').textContent = '?××” ×”× ×™×§×•×“ ×”× ×›×•×Ÿ';
  document.getElementById('question-word').textContent = stripNikud(word.nikud);

  // Generate options: 1 correct + 3 fakes (guaranteed different from correct)
  const correctText = normalizeNikud(word.nikud);
  let optionTexts = [];
  const usedTexts = new Set([correctText]);
  let attempts = 0;
  while (optionTexts.length < 3 && attempts < 40) {
    const fake = generateFakeNikud(word);
    if (!usedTexts.has(fake)) {
      optionTexts.push(fake);
      usedTexts.add(fake);
    }
    attempts++;
  }

  // Insert correct answer at random position
  const correctIndex = Math.floor(Math.random() * (optionTexts.length + 1));
  optionTexts.splice(correctIndex, 0, correctText);

  const area = document.getElementById('options-area');
  area.innerHTML = '';
  answerLocked = false;
  optionTexts.forEach((optText, idx) => {
    const btn = document.createElement('button');
    btn.className = 'btn-option';
    btn.textContent = optText;
    btn.dataset.correct = (idx === correctIndex) ? 'yes' : 'no';
    btn.onclick = function(e) {
      if (answerLocked) return;
      answerLocked = true;
      area.querySelectorAll('.btn-option').forEach(b => b.disabled = true);
      if (btn.dataset.correct === 'yes') {
        btn.classList.add('correct');
        score++;
        playCorrectSound();
        spawnStarParticles(e.clientX, e.clientY);
        showFeedback(true);
      } else {
        btn.classList.add('wrong');
        area.querySelectorAll('.btn-option').forEach(b => {
          if (b.dataset.correct === 'yes') b.classList.add('correct');
        });
        playWrongSound();
        showFeedback(false, correctText + ' :×”×ª×©×•×‘×” ×”× ×›×•× ×”');
      }
    };
    area.appendChild(btn);
  });
}

// ===== MODE 2: MATCH WORD TO MEANING =====
function showMeaningQuestion(word) {
  document.getElementById('question-label').textContent = '?××” ×”××©××¢×•×ª ×©×œ ×”××™×œ×”';
  document.getElementById('question-word').textContent = word.nikud;

  // Get distractors from other words (ensure unique meanings)
  const correctMeaning = word.meaning;
  const others = WORDS.filter(w => w.meaning !== correctMeaning);
  const distractors = pick(others, Math.min(3, others.length));

  let optionTexts = [];
  const usedMeanings = new Set([correctMeaning]);
  distractors.forEach(d => {
    if (!usedMeanings.has(d.meaning)) {
      optionTexts.push(d.meaning);
      usedMeanings.add(d.meaning);
    }
  });

  // Insert correct answer at random position
  const correctIndex = Math.floor(Math.random() * (optionTexts.length + 1));
  optionTexts.splice(correctIndex, 0, correctMeaning);

  const area = document.getElementById('options-area');
  area.innerHTML = '';
  answerLocked = false;
  optionTexts.forEach((optText, idx) => {
    const btn = document.createElement('button');
    btn.className = 'btn-option';
    btn.textContent = optText;
    btn.dataset.correct = (idx === correctIndex) ? 'yes' : 'no';
    btn.onclick = function(e) {
      if (answerLocked) return;
      answerLocked = true;
      area.querySelectorAll('.btn-option').forEach(b => b.disabled = true);
      if (btn.dataset.correct === 'yes') {
        btn.classList.add('correct');
        score++;
        playCorrectSound();
        spawnStarParticles(e.clientX, e.clientY);
        showFeedback(true);
      } else {
        btn.classList.add('wrong');
        area.querySelectorAll('.btn-option').forEach(b => {
          if (b.dataset.correct === 'yes') b.classList.add('correct');
        });
        playWrongSound();
        showFeedback(false, correctMeaning + ' :×”×ª×©×•×‘×”');
      }
    };
    area.appendChild(btn);
  });
}

// ===== MODE 4: VOICE - HEAR AND PICK CORRECT NIKUD =====
function showVoiceQuestion(word) {
  document.getElementById('question-label').textContent = '?×”×§×©×™×‘×• ×•×‘×—×¨×• ××ª ×”××™×œ×” ×”× ×›×•× ×”';
  document.getElementById('question-word').innerHTML = '';

  const area = document.getElementById('options-area');
  area.innerHTML = '';

  // Speaker button
  const speakerBtn = document.createElement('button');
  speakerBtn.className = 'speaker-btn';
  speakerBtn.textContent = 'ğŸ”Š';
  speakerBtn.title = '×œ×—×¦×• ×œ×©××•×¢';
  speakerBtn.onclick = function() {
    speakerBtn.style.animation = 'none';
    void speakerBtn.offsetWidth; // trigger reflow
    speakerBtn.style.animation = 'bounce 0.4s';
    playWordAudio(word.nikud, word.speak);
  };

  const hint = document.createElement('div');
  hint.className = 'speaker-hint';
  hint.textContent = 'ğŸ‘† ×œ×—×¦×• ×œ×©××•×¢ ××ª ×”××™×œ×”';

  const wordArea = document.getElementById('question-word');
  wordArea.innerHTML = '';
  wordArea.appendChild(speakerBtn);
  wordArea.appendChild(hint);

  // Auto-play the word after a short delay
  setTimeout(() => playWordAudio(word.nikud, word.speak), 400);

  // Generate options: correct nikud + up to 3 distractors
  const correctText = normalizeNikud(word.nikud);
  const others = WORDS.filter(w => normalizeNikud(w.nikud) !== correctText);
  const realDistractors = pick(others, Math.min(3, others.length));

  let optionTexts = [];
  const usedTexts = new Set([correctText]);
  realDistractors.forEach(d => {
    const norm = normalizeNikud(d.nikud);
    if (!usedTexts.has(norm)) {
      optionTexts.push(norm);
      usedTexts.add(norm);
    }
  });

  // If we still don't have 3 wrong options, generate fake nikud
  let fakeAttempts = 0;
  while (optionTexts.length < 3 && fakeAttempts < 30) {
    const fake = generateFakeNikud(word);
    if (!usedTexts.has(fake)) {
      optionTexts.push(fake);
      usedTexts.add(fake);
    }
    fakeAttempts++;
  }

  // Insert correct answer at random position
  const correctIndex = Math.floor(Math.random() * (optionTexts.length + 1));
  optionTexts.splice(correctIndex, 0, correctText);

  answerLocked = false;
  optionTexts.forEach((optText, idx) => {
    const btn = document.createElement('button');
    btn.className = 'btn-option';
    btn.textContent = optText;
    btn.dataset.correct = (idx === correctIndex) ? 'yes' : 'no';
    btn.onclick = function(e) {
      if (answerLocked) return;
      answerLocked = true;
      area.querySelectorAll('.btn-option').forEach(b => b.disabled = true);
      if (btn.dataset.correct === 'yes') {
        btn.classList.add('correct');
        score++;
        playCorrectSound();
        spawnStarParticles(e.clientX, e.clientY);
        showFeedback(true);
      } else {
        btn.classList.add('wrong');
        area.querySelectorAll('.btn-option').forEach(b => {
          if (b.dataset.correct === 'yes') b.classList.add('correct');
        });
        playWrongSound();
        showFeedback(false, correctText + ' :×”×ª×©×•×‘×” ×”× ×›×•× ×”');
      }
    };
    area.appendChild(btn);
  });
}

// ===== MODE 3: MEMORY PAIRS =====
function showMemoryQuestion(words) {
  document.getElementById('question-label').textContent = '!××¦××• ××ª ×”×–×•×’×•×ª - ×”×ª××™××• ××™×œ×” ×œ××©××¢×•×ª';
  document.getElementById('question-word').textContent = 'ğŸƒ';

  // Create cards: word-nikud cards + meaning cards
  let cards = [];
  words.forEach((w, i) => {
    cards.push({ id: 'w'+i, pairId: i, text: w.nikud, type: 'word' });
    cards.push({ id: 'm'+i, pairId: i, text: w.meaning, type: 'meaning' });
  });
  cards = shuffle(cards);

  memoryState = {
    words: words,
    flipped: [],
    matched: 0,
    total: words.length,
    locked: false
  };

  const area = document.getElementById('options-area');
  area.innerHTML = '';
  const grid = document.createElement('div');
  grid.className = 'memory-grid';

  cards.forEach(card => {
    const cardEl = document.createElement('div');
    cardEl.className = 'memory-card';
    cardEl.dataset.pairId = card.pairId;
    cardEl.dataset.cardId = card.id;

    cardEl.innerHTML = `
      <div class="memory-card-inner">
        <div class="memory-card-front">?</div>
        <div class="memory-card-back">${card.text}</div>
      </div>
    `;

    cardEl.onclick = function(e) { handleMemoryClick(cardEl, e); };
    grid.appendChild(cardEl);
  });

  area.appendChild(grid);
}

function handleMemoryClick(cardEl, e) {
  if (!memoryState || memoryState.locked) return;
  if (cardEl.classList.contains('flipped') || cardEl.classList.contains('matched')) return;

  cardEl.classList.add('flipped');
  memoryState.flipped.push(cardEl);

  if (memoryState.flipped.length === 2) {
    memoryState.locked = true;
    const [card1, card2] = memoryState.flipped;
    const pair1 = card1.dataset.pairId;
    const pair2 = card2.dataset.pairId;
    const id1 = card1.dataset.cardId;
    const id2 = card2.dataset.cardId;

    if (pair1 === pair2 && id1 !== id2) {
      // Match!
      setTimeout(() => {
        card1.classList.add('matched');
        card2.classList.add('matched');
        playMatchSound();
        spawnStarParticles(e.clientX, e.clientY);
        memoryState.matched++;
        score++;
        currentQuestion++;
        updateUI();

        if (memoryState.matched === memoryState.total) {
          // All matched - memory round done
          setTimeout(() => {
            showFeedback(true);
          }, 400);
        }
        memoryState.flipped = [];
        memoryState.locked = false;
      }, 400);
    } else {
      // No match
      setTimeout(() => {
        card1.classList.remove('flipped');
        card2.classList.remove('flipped');
        memoryState.flipped = [];
        memoryState.locked = false;
      }, 800);
    }
  }
}

// ===== MODE: WORD ASSEMBLY =====

// Parse nikud word into segments: each base letter + its combining marks
function parseWordSegments(nikudWord) {
  const segments = [];
  let current = '';
  for (const ch of nikudWord) {
    if (ch >= '\u05D0' && ch <= '\u05EA') {
      if (current) segments.push(current);
      current = ch;
    } else {
      current += ch;
    }
  }
  if (current) segments.push(current);
  return segments;
}

// All Hebrew base letters for generating distractors
const ALL_HEBREW_LETTERS = '××‘×’×“×”×•×–×—×˜×™×›×œ×× ×¡×¢×¤×¦×§×¨×©×ª'.split('');
const ALL_NIKUD_MARKS_LIST = ['\u05B0','\u05B1','\u05B2','\u05B3','\u05B4','\u05B5','\u05B6','\u05B7','\u05B8','\u05B9','\u05BB','\u05BC'];

function showAssembleQuestion(word) {
  document.getElementById('question-label').textContent = '!×”×§×©×™×‘×• ×•×”×¨×›×™×‘×• ××ª ×”××™×œ×”';
  document.getElementById('question-word').innerHTML = '';

  const area = document.getElementById('options-area');
  area.innerHTML = '';

  // Speaker button
  const speakerBtn = document.createElement('button');
  speakerBtn.className = 'speaker-btn';
  speakerBtn.textContent = 'ğŸ”Š';
  speakerBtn.onclick = function() {
    speakerBtn.style.animation = 'none';
    void speakerBtn.offsetWidth;
    speakerBtn.style.animation = 'bounce 0.4s';
    playWordAudio(word.nikud, word.speak);
  };

  const hint = document.createElement('div');
  hint.className = 'speaker-hint';
  hint.textContent = 'ğŸ‘† ×œ×—×¦×• ×œ×©××•×¢ ××ª ×”××™×œ×”';

  const wordArea = document.getElementById('question-word');
  wordArea.appendChild(speakerBtn);
  wordArea.appendChild(hint);

  // Auto-play
  setTimeout(() => playWordAudio(word.nikud, word.speak), 400);

  if (difficulty === 'easy') {
    showAssembleEasy(word, area);
  } else {
    showAssembleAdvanced(word, area);
  }
}

// ---- EASY MODE: base letters only, reveal nikud on success ----
function showAssembleEasy(word, area) {
  const fullSegments = parseWordSegments(word.nikud);
  const baseLetters = fullSegments.map(seg => seg[0]);
  const correctOrder = [...baseLetters];

  // Add 2-3 distractor letters not in the word
  const wordLetterSet = new Set(baseLetters);
  const distractors = shuffle(ALL_HEBREW_LETTERS.filter(l => !wordLetterSet.has(l)))
    .slice(0, Math.min(3, Math.max(2, Math.floor(baseLetters.length * 0.5))));
  const allPieces = shuffle([...baseLetters, ...distractors]);

  // Track which pieces are distractors (after shuffle)
  // We need to know for styling: a piece is a distractor if removing it still leaves
  // enough of that letter for the word. Simpler: mark indices that came from distractors.
  const distractorSet = new Set(distractors);

  // State
  const placed = new Array(correctOrder.length).fill(null); // slotIndex -> pieceIndex
  const pieceUsed = new Array(allPieces.length).fill(false);

  // Drop zone
  const dropzone = document.createElement('div');
  dropzone.className = 'assemble-dropzone';

  const slots = [];
  for (let i = 0; i < correctOrder.length; i++) {
    const slot = createSlot(i);
    slots.push(slot);
    dropzone.appendChild(slot);
  }

  // Pieces
  const piecesContainer = document.createElement('div');
  piecesContainer.className = 'assemble-pieces';

  // Figure out which allPieces indices are distractors:
  // Count needed per letter, then mark extras
  const neededCount = {};
  baseLetters.forEach(l => { neededCount[l] = (neededCount[l] || 0) + 1; });
  const seenCount = {};
  const isDistractorIdx = allPieces.map(l => {
    seenCount[l] = (seenCount[l] || 0) + 1;
    return seenCount[l] > (neededCount[l] || 0);
  });

  const pieces = [];
  allPieces.forEach((seg, idx) => {
    const piece = createPiece(idx, seg, 'letter', isDistractorIdx[idx]);
    pieces.push(piece);
    piecesContainer.appendChild(piece);
  });

  area.appendChild(dropzone);
  area.appendChild(piecesContainer);

  // --- interaction logic ---
  function placePiece(pieceIdx, slotIdx) {
    if (pieceUsed[pieceIdx]) return;
    if (placed[slotIdx] !== null) return;
    placed[slotIdx] = pieceIdx;
    pieceUsed[pieceIdx] = true;
    slots[slotIdx].textContent = allPieces[pieceIdx];
    slots[slotIdx].classList.add('filled');
    pieces[pieceIdx].classList.add('used');
    if (!placed.includes(null)) checkResult();
  }

  function removePiece(slotIdx) {
    if (placed[slotIdx] === null) return;
    const pIdx = placed[slotIdx];
    placed[slotIdx] = null;
    pieceUsed[pIdx] = false;
    slots[slotIdx].textContent = '';
    slots[slotIdx].classList.remove('filled');
    pieces[pIdx].classList.remove('used');
  }

  function checkResult() {
    const assembled = placed.map(pi => allPieces[pi]);
    const isCorrect = assembled.every((seg, i) => seg === correctOrder[i]);
    if (isCorrect) {
      score++;
      playCorrectSound();
      slots.forEach(s => s.classList.add('correct-slot'));
      // Reveal nikud
      fullSegments.forEach((seg, i) => { if (i < slots.length) slots[i].textContent = seg; });
      const rect = dropzone.getBoundingClientRect();
      spawnStarParticles(rect.left + rect.width/2, rect.top);
      setTimeout(() => showFeedback(true), 600);
    } else {
      playWrongSound();
      dropzone.style.animation = 'shake 0.5s';
      setTimeout(() => {
        dropzone.style.animation = '';
        for (let i = 0; i < placed.length; i++) removePiece(i);
      }, 600);
    }
  }

  // Wire up interactions
  wireAssembleInteractions(slots, pieces, placed, pieceUsed, placePiece, removePiece);
}

// ---- ADVANCED MODE: letters + nikud on same slots ----
// Each slot = one letter position. Child places a letter, then places nikud ON that letter.
// The nikud renders naturally combined with the letter (e.g. ×—Ö·).
function showAssembleAdvanced(word, area) {
  const fullSegments = parseWordSegments(word.nikud);
  const numSlots = fullSegments.length;

  // Correct answers per slot
  const correctLetters = fullSegments.map(seg => seg[0]);
  const correctNikud = fullSegments.map(seg => seg.length > 1 ? seg.slice(1) : ''); // marks string or ''

  // Build letter pieces with distractors
  const wordLetterSet = new Set(correctLetters);
  const letterDistractors = shuffle(ALL_HEBREW_LETTERS.filter(l => !wordLetterSet.has(l)))
    .slice(0, Math.min(3, Math.max(2, Math.floor(correctLetters.length * 0.4))));
  const allLetterPieces = shuffle([...correctLetters, ...letterDistractors]);

  // Figure out which letter piece indices are distractors
  const neededLetterCount = {};
  correctLetters.forEach(l => { neededLetterCount[l] = (neededLetterCount[l] || 0) + 1; });
  const seenLetterCount = {};
  const isLetterDistractor = allLetterPieces.map(l => {
    seenLetterCount[l] = (seenLetterCount[l] || 0) + 1;
    return seenLetterCount[l] > (neededLetterCount[l] || 0);
  });

  // Build nikud pieces with distractors
  // Collect unique nikud marks from the word
  const wordNikudList = correctNikud.filter(n => n.length > 0);
  const wordNikudSet = new Set(wordNikudList);
  const nikudDistractors = shuffle(ALL_NIKUD_MARKS_LIST.filter(n => !wordNikudSet.has(n)))
    .slice(0, Math.min(3, Math.max(1, Math.floor(wordNikudList.length * 0.5))));
  const allNikudPieces = shuffle([...wordNikudList, ...nikudDistractors]);

  // Figure out which nikud piece indices are distractors
  const neededNikudCount = {};
  wordNikudList.forEach(n => { neededNikudCount[n] = (neededNikudCount[n] || 0) + 1; });
  const seenNikudCount = {};
  const isNikudDistractor = allNikudPieces.map(n => {
    seenNikudCount[n] = (seenNikudCount[n] || 0) + 1;
    return seenNikudCount[n] > (neededNikudCount[n] || 0);
  });

  // State per slot: { letter: pieceIdx|null, nikud: pieceIdx|null }
  const slotState = Array.from({ length: numSlots }, () => ({ letter: null, nikud: null }));
  const letterUsed = new Array(allLetterPieces.length).fill(false);
  const nikudUsed = new Array(allNikudPieces.length).fill(false);

  // Drop zone
  const dropzone = document.createElement('div');
  dropzone.className = 'assemble-dropzone';

  const slots = [];
  for (let i = 0; i < numSlots; i++) {
    const slot = createSlot(i);
    // Mark slots that need nikud with a visual hint
    if (correctNikud[i].length > 0) slot.classList.add('needs-nikud');
    slots.push(slot);
    dropzone.appendChild(slot);
  }

  // Letter pieces
  const letterLabel = document.createElement('div');
  letterLabel.className = 'assemble-section-label';
  letterLabel.textContent = 'ğŸ“ ××•×ª×™×•×ª';

  const letterContainer = document.createElement('div');
  letterContainer.className = 'assemble-pieces';

  const letterPieceEls = [];
  allLetterPieces.forEach((seg, idx) => {
    const piece = createPiece(idx, seg, 'letter', isLetterDistractor[idx]);
    letterPieceEls.push(piece);
    letterContainer.appendChild(piece);
  });

  // Nikud pieces
  const nikudLabel = document.createElement('div');
  nikudLabel.className = 'assemble-section-label';
  nikudLabel.textContent = 'âœ¨ × ×™×§×•×“';

  const nikudContainer = document.createElement('div');
  nikudContainer.className = 'assemble-pieces';

  const nikudPieceEls = [];
  allNikudPieces.forEach((seg, idx) => {
    const piece = createPiece(idx, seg, 'nikud', isNikudDistractor[idx]);
    piece.classList.add('nikud-piece');
    // Show nikud on dotted circle for visibility
    piece.innerHTML = '<span style="font-size:28px;">\u25CC' + seg + '</span>';
    nikudPieceEls.push(piece);
    nikudContainer.appendChild(piece);
  });

  // Check button (shown when all letters placed)
  const checkBtn = document.createElement('button');
  checkBtn.className = 'btn-add';
  checkBtn.textContent = 'âœ… ×‘×“×•×§';
  checkBtn.style.display = 'none';
  checkBtn.style.margin = '16px auto';
  checkBtn.onclick = checkResult;

  area.appendChild(dropzone);
  area.appendChild(letterLabel);
  area.appendChild(letterContainer);
  area.appendChild(nikudLabel);
  area.appendChild(nikudContainer);
  area.appendChild(checkBtn);

  function renderSlot(si) {
    const st = slotState[si];
    if (st.letter === null) {
      slots[si].textContent = '';
      slots[si].classList.remove('filled', 'has-nikud');
    } else {
      // Combine letter + nikud marks naturally
      let display = allLetterPieces[st.letter];
      if (st.nikud !== null) {
        display += allNikudPieces[st.nikud];
        slots[si].classList.add('has-nikud');
      } else {
        slots[si].classList.remove('has-nikud');
      }
      slots[si].textContent = display;
      slots[si].classList.add('filled');
    }
    // Show/hide check button when all letter slots are filled
    const allLettersFilled = slotState.every(s => s.letter !== null);
    checkBtn.style.display = allLettersFilled ? 'block' : 'none';
  }

  function placeLetterOnSlot(pieceIdx, slotIdx) {
    if (letterUsed[pieceIdx]) return;
    if (slotState[slotIdx].letter !== null) return; // slot already has a letter
    slotState[slotIdx].letter = pieceIdx;
    letterUsed[pieceIdx] = true;
    letterPieceEls[pieceIdx].classList.add('used');
    renderSlot(slotIdx);
  }

  function placeNikudOnSlot(pieceIdx, slotIdx) {
    if (nikudUsed[pieceIdx]) return;
    if (slotState[slotIdx].letter === null) return; // must have a letter first
    // If slot already has nikud, remove old one first
    if (slotState[slotIdx].nikud !== null) {
      const oldIdx = slotState[slotIdx].nikud;
      nikudUsed[oldIdx] = false;
      nikudPieceEls[oldIdx].classList.remove('used');
    }
    slotState[slotIdx].nikud = pieceIdx;
    nikudUsed[pieceIdx] = true;
    nikudPieceEls[pieceIdx].classList.add('used');
    renderSlot(slotIdx);
  }

  function handleSlotTap(slotIdx) {
    const st = slotState[slotIdx];
    // First tap: remove nikud if present
    if (st.nikud !== null) {
      nikudUsed[st.nikud] = false;
      nikudPieceEls[st.nikud].classList.remove('used');
      st.nikud = null;
      renderSlot(slotIdx);
      return;
    }
    // Second tap: remove letter
    if (st.letter !== null) {
      letterUsed[st.letter] = false;
      letterPieceEls[st.letter].classList.remove('used');
      st.letter = null;
      renderSlot(slotIdx);
    }
  }

  function handleDrop(pieceIdx, pool, slotIdx) {
    if (pool === 'letter') placeLetterOnSlot(pieceIdx, slotIdx);
    else if (pool === 'nikud') placeNikudOnSlot(pieceIdx, slotIdx);
  }

  function checkResult() {
    // Build assembled segments and compare
    const isCorrect = slotState.every((st, i) => {
      if (st.letter === null) return false;
      if (allLetterPieces[st.letter] !== correctLetters[i]) return false;
      const placedNikud = st.nikud !== null ? allNikudPieces[st.nikud] : '';
      return placedNikud === correctNikud[i];
    });

    if (isCorrect) {
      score++;
      playCorrectSound();
      slots.forEach((s, i) => {
        s.textContent = fullSegments[i];
        s.classList.add('correct-slot');
      });
      checkBtn.style.display = 'none';
      const rect = dropzone.getBoundingClientRect();
      spawnStarParticles(rect.left + rect.width/2, rect.top);
      setTimeout(() => showFeedback(true), 600);
    } else {
      playWrongSound();
      dropzone.style.animation = 'shake 0.5s';
      setTimeout(() => {
        dropzone.style.animation = '';
        // Reset everything
        for (let i = 0; i < numSlots; i++) {
          const st = slotState[i];
          if (st.nikud !== null) { nikudUsed[st.nikud] = false; nikudPieceEls[st.nikud].classList.remove('used'); st.nikud = null; }
          if (st.letter !== null) { letterUsed[st.letter] = false; letterPieceEls[st.letter].classList.remove('used'); st.letter = null; }
          renderSlot(i);
        }
      }, 600);
    }
  }

  // Wire up interactions
  wireAdvancedInteractions(slots, letterPieceEls, nikudPieceEls, handleDrop, handleSlotTap);
}

// ---- Shared: create a slot element ----
function createSlot(index) {
  const slot = document.createElement('div');
  slot.className = 'assemble-slot';
  slot.dataset.slotIndex = index;
  return slot;
}

// ---- Shared: create a piece element ----
function createPiece(index, text, pool, isDistractor) {
  const piece = document.createElement('div');
  piece.className = 'assemble-piece' + (isDistractor ? ' distractor' : '');
  piece.textContent = text;
  piece.dataset.pieceIndex = index;
  piece.dataset.pool = pool;
  piece.draggable = true;
  piece.setAttribute('role', 'button');
  piece.tabIndex = 0;
  return piece;
}

// ---- DRAG/TAP wiring for EASY mode ----
function wireAssembleInteractions(slots, pieces, placed, pieceUsed, placeFn, removeFn) {
  pieces.forEach((piece, idx) => {
    piece.addEventListener('click', () => {
      if (pieceUsed[idx]) return;
      const emptySlot = placed.indexOf(null);
      if (emptySlot === -1) return;
      placeFn(idx, emptySlot);
    });

    piece.addEventListener('dragstart', e => {
      e.dataTransfer.setData('text/plain', JSON.stringify({ pool: 'letter', idx }));
      piece.classList.add('dragging');
    });
    piece.addEventListener('dragend', () => piece.classList.remove('dragging'));

    setupTouchDrag(piece, idx, 'letter', slots, (pIdx, sIdx) => placeFn(pIdx, sIdx));
  });

  slots.forEach((slot, si) => {
    slot.addEventListener('click', () => removeFn(si));

    slot.addEventListener('dragover', e => { e.preventDefault(); slot.classList.add('drag-over'); });
    slot.addEventListener('dragleave', () => slot.classList.remove('drag-over'));
    slot.addEventListener('drop', e => {
      e.preventDefault();
      slot.classList.remove('drag-over');
      try {
        const data = JSON.parse(e.dataTransfer.getData('text/plain'));
        if (placed[si] === null) placeFn(data.idx, si);
      } catch(err) {}
    });
  });
}

// ---- DRAG/TAP wiring for ADVANCED mode ----
function wireAdvancedInteractions(slots, letterPieceEls, nikudPieceEls, handleDrop, handleSlotTap) {
  function wirePool(pieceEls, pool, allSlots) {
    pieceEls.forEach((piece, idx) => {
      piece.addEventListener('click', () => {
        if (piece.classList.contains('used')) return;
        // Find first eligible slot
        if (pool === 'letter') {
          // Find first slot without a letter
          const si = allSlots.findIndex((_, i) => {
            // Access slotState from closure â€” check DOM state
            return !allSlots[i].classList.contains('filled') || false;
          });
          // Actually we just need the first empty slot. Check via textContent:
          for (let i = 0; i < allSlots.length; i++) {
            // A slot is letter-empty if it has no filled class or no text
            if (!allSlots[i].classList.contains('filled')) {
              handleDrop(idx, pool, i);
              return;
            }
          }
        } else {
          // Nikud: find first slot that has a letter but could use nikud
          for (let i = 0; i < allSlots.length; i++) {
            if (allSlots[i].classList.contains('filled') && allSlots[i].classList.contains('needs-nikud') && !allSlots[i].classList.contains('has-nikud')) {
              handleDrop(idx, pool, i);
              return;
            }
          }
        }
      });

      piece.addEventListener('dragstart', e => {
        e.dataTransfer.setData('text/plain', JSON.stringify({ pool, idx }));
        piece.classList.add('dragging');
      });
      piece.addEventListener('dragend', () => piece.classList.remove('dragging'));

      setupTouchDrag(piece, idx, pool, allSlots, (pIdx, sIdx) => handleDrop(pIdx, pool, sIdx));
    });
  }

  wirePool(letterPieceEls, 'letter', slots);
  wirePool(nikudPieceEls, 'nikud', slots);

  slots.forEach((slot, si) => {
    slot.addEventListener('click', () => handleSlotTap(si));

    slot.addEventListener('dragover', e => { e.preventDefault(); slot.classList.add('drag-over'); });
    slot.addEventListener('dragleave', () => slot.classList.remove('drag-over'));
    slot.addEventListener('drop', e => {
      e.preventDefault();
      slot.classList.remove('drag-over');
      try {
        const data = JSON.parse(e.dataTransfer.getData('text/plain'));
        handleDrop(data.idx, data.pool, si);
      } catch(err) {}
    });
  });
}

// ---- Touch drag support (for mobile) ----
function setupTouchDrag(piece, pieceIdx, pool, slots, placeFn) {
  let ghost = null;

  piece.addEventListener('touchstart', e => {
    if (piece.classList.contains('used')) return;
    const touch = e.touches[0];

    ghost = piece.cloneNode(true);
    ghost.style.position = 'fixed';
    ghost.style.zIndex = '300';
    ghost.style.pointerEvents = 'none';
    ghost.style.opacity = '0.85';
    ghost.style.transform = 'scale(1.15)';
    ghost.style.transition = 'none';
    ghost.style.left = (touch.clientX - 30) + 'px';
    ghost.style.top = (touch.clientY - 35) + 'px';
    document.body.appendChild(ghost);
    piece.classList.add('dragging');
  }, { passive: true });

  piece.addEventListener('touchmove', e => {
    if (!ghost) return;
    e.preventDefault();
    const touch = e.touches[0];
    ghost.style.left = (touch.clientX - 30) + 'px';
    ghost.style.top = (touch.clientY - 35) + 'px';

    slots.forEach(s => s.classList.remove('drag-over'));
    const el = document.elementFromPoint(touch.clientX, touch.clientY);
    if (el && el.classList.contains('assemble-slot')) {
      el.classList.add('drag-over');
    }
  }, { passive: false });

  piece.addEventListener('touchend', e => {
    piece.classList.remove('dragging');
    if (!ghost) return;
    ghost.remove();
    ghost = null;

    const touch = e.changedTouches[0];
    slots.forEach(s => s.classList.remove('drag-over'));

    const el = document.elementFromPoint(touch.clientX, touch.clientY);
    if (el && el.classList.contains('assemble-slot')) {
      const slotIdx = parseInt(el.dataset.slotIndex);
      placeFn(pieceIdx, slotIdx);
    }
  }, { passive: true });
}

// ===== END GAME =====
function endGame() {
  playEndSound();
  showScreen('end-screen');

  let starsStr = '';
  for (let i = 0; i < score; i++) starsStr += 'â­';
  if (score === 0) starsStr = 'ğŸ’ª';
  document.getElementById('end-stars').textContent = starsStr;
  document.getElementById('end-score').textContent = totalQuestions + ' ××ª×•×š ' + score + ' â­';

  let msg;
  if (score >= 9) msg = '!××“×”×™×! ××ª× ××œ×•×¤×™×';
  else if (score >= 7) msg = '!×™×•×¤×™! ×¢×‘×•×“×” ××¦×•×™× ×ª';
  else if (score >= 5) msg = '!×˜×•×‘ ×××•×“! ×”××©×™×›×• ×œ×ª×¨×’×œ';
  else msg = '!×œ× × ×•×¨×, × × ×¡×” ×©×•×‘';
  document.getElementById('end-message').textContent = msg;
}
</script>

</body>
</html>
